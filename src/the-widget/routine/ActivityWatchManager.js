// Generated by CoffeeScript 1.12.6
(function() {
  var ActivityWatchManager, ActivityWatcher, pkg,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  pkg = window.thewidget = window.thewidget || {};

  pkg = pkg.routine = pkg.routine || {};

  ActivityWatcher = pkg.ActivityWatcher;


  /**
   * Клас-прослойка між серверами сайтів, віджет-менеджером і езамплярами віджетів на сторінці.
   * Клас гарантує те, що всі віджети, які працюють з одним і тим же сайтом будуть отримувати дані з
   * єдиного джерела. Таким чином знижується навантаження як на трафік, так і на самі сервери сайтів.
   * В принципі достатньо і одного віджета для моніторингу одного сайту, але чим чорт не шутить... В кінці
   * кінців форми для вводу коментарів роблять перед і після блоку коментарів - віключно для зручності.
   *
   * ActivityWatchManager дозволяє інтересантам активності на сайтах оформляти підписку, відміняти чи переоформляти її.
   * Таким чином неслабо розвантажується основний код віджет-менеджера.
   *
   * Також ActivityWatchManager зберігає адреси всіх підключених сайтів, що може допомогти при створенні копій віджетів,
   * які працюють з одним і тим же сайтом - в панелі настройки віджету буде можливість використати адреси відомих сайтів.
   */

  ActivityWatchManager = (function() {
    ActivityWatchManager.prototype._cache = null;

    ActivityWatchManager.prototype._cfg = null;

    function ActivityWatchManager(delay, serverUrl, fnParser, subsClbName) {
      this._watchCallback = bind(this._watchCallback, this);
      this._cache = {
        watch2subs: new Dictionary(),
        subs2watch: new Dictionary(),
        site2watch: new Dictionary()
      };
      this._cfg = {
        delay: delay || 0,
        serverUrl: serverUrl || "",
        fnParser: fnParser,
        subsClbName: subsClbName || ""
      };
    }

    ActivityWatchManager.prototype.getKnownSites = function() {
      return this._cache.site2watch.keys(false);
    };

    ActivityWatchManager.prototype.subscribe = function(subscriber, site) {
      var arrSubs, watcher;
      if (subscriber != null) {
        this.unsubscribe(subscriber);
        watcher = this._getWatcher(site);
        arrSubs = this._cache.watch2subs.get(watcher);
        arrSubs.push(subscriber);
        this._cache.subs2watch.set(subscriber, watcher);
        if (arrSubs.length > 0) {
          return watcher.awake();
        }
      }
    };

    ActivityWatchManager.prototype.unsubscribe = function(subscriber) {
      var arrSubs, idx, watcher;
      watcher = this._cache.subs2watch.get(subscriber);
      this._cache.subs2watch.del(subscriber);
      if ((subscriber != null) && (watcher != null)) {
        arrSubs = this._cache.watch2subs.get(watcher);
        idx = arrSubs.indexOf(subscriber);
        if (idx !== -1) {
          arrSubs.splice(idx, 1);
        }
        if (arrSubs.length === 0) {
          return watcher.sleep();
        }
      }
    };

    ActivityWatchManager.prototype._getWatcher = function(site) {
      var url, watcher;
      watcher = this._cache.site2watch.get(site);
      if (watcher == null) {
        url = site + "/" + this._cfg.serverUrl;
        watcher = new ActivityWatcher(url, this._cfg.delay, this._watchCallback);
        this._cache.site2watch.set(site, watcher);
        this._cache.watch2subs.set(watcher, []);
      }
      return watcher;
    };

    ActivityWatchManager.prototype._watchCallback = function(data, watcher) {
      var arrSubs, clbName, i, info, len, parser, results, subs;
      arrSubs = this._cache.watch2subs.get(watcher);
      parser = this._cfg.fnParser;
      info = (parser != null ? parser.call(null, data) : data);
      clbName = this._cfg.subsClbName;
      results = [];
      for (i = 0, len = arrSubs.length; i < len; i++) {
        subs = arrSubs[i];
        results.push(subs[clbName].call(subs, info));
      }
      return results;
    };

    return ActivityWatchManager;

  })();

  pkg.ActivityWatchManager = ActivityWatchManager;

}).call(this);
