// Generated by CoffeeScript 1.12.6
(function() {
  var blueprint, pkg, strChart, strTemplate, theWidgetInstConfig, theWidgetInstData;

  pkg = window.thewidget = window.thewidget || {};


  /*
    Дві наступні функції могли бути просто змінними зі строковими значеннями, але в погоні за читабельністю
    і скролябельністю я вибрав іменно функції, тому що ФОЛДІНГ
   */

  strTemplate = function() {
    return "<div class=\"b-the-widget\">\n<div class=\"b-the-widget__header\">\n	<span>Site activity: <a href=\"\" title=\"{{@this.siteName(site)}}\">{{@this.siteName(site)}}</a></span>\n</div>\n<div class=\"b-the-widget__btn\" on-click=\"suicide\">&times;</div>\n\n{{>chart}}\n\n<div class=\"b-the-widget__summary-box\">\n	<div class=\"b-the-widget__summary-piece\">lim: {{limUsers}}</div>\n	<div class=\"b-the-widget__summary-piece\">min: {{minUsers}}</div>\n	<div class=\"b-the-widget__summary-piece\">max: {{maxUsers}}</div>\n	<div class=\"b-the-widget__summary-piece\">avg: {{avgUsers}}</div>\n</div>\n\n</div>";
  };

  strChart = function() {
    return "<svg class='b-widget-chart' width=\"{{cfg.easel.width}}\" height=\"{{cfg.easel.height}}\">\n<defs>\n	<linearGradient\n			id=\"{{hotBgId}}\"\n			gradientUnits=\"objectBoundingBox\"\n			spreadMethod=\"pad\"\n			x1=\"0%\" x2=\"0%\" y1=\"0%\" y2=\"100%\">\n		<stop offset=\"25%\"\n		      style=\"stop-color: {{barColor}};\"/>\n		<stop offset=\"100%\"\n		      style=\"stop-color: black;\"/>\n	</linearGradient>\n</defs>\n\n<rect class=\"b-widget-chart__bg\"\n      x=\"0\" y=\"0\"\n      width=\"{{cfg.easel.width}}\" height=\"{{cfg.easel.height}}\"/>\n\n<line class=\"b-widget-chart__base-line\"\n      x1=\"1\" y1=\"{{cfg.baseLine}}\"\n      x2=\"{{cfg.easel.width-1}}\" y2=\"{{cfg.baseLine}}\"/>\n\n<g transform=\"translate({{0.5*cfg.bar.spacer}}, {{cfg.baseLine}}), scale(1, -1)\">\n	{{#each drawData:idx}}\n		{{#with bar}}\n			<rect\n				x=\"{{idx*(cfg.bar.width+cfg.bar.spacer)}}\"\n				y=\"{{y}}\"\n				width=\"{{w}}\"\n				height=\"{{h}}\"\n				fill=\"{{bg}}\"/>\n		{{/with}}\n		{{#with lbl}}\n			<text\n				class=\"{{cls}}\"\n				x=\"0\"\n				y=\"0\"\n				transform=\"scale(1, -1), rotate(-90), translate({{y}}, {{x}})\">{{text}}</text>\n		{{/with}}\n	{{/each}}\n</g>\n</svg>";
  };


  /*
    Набір параметрів візуалізацї для віджетів. Навмисне винесений за межі класу, тому що нема
    необхідності плодити єкземпляри цього хешу, адже ці параметри є спільними для всіх віджетів
   */

  theWidgetInstConfig = {
    historySize: 25,
    baseLine: 155,
    thisSite: "-=[ this site ]=-",
    easel: {
      width: 300,
      height: 160
    },
    bar: {
      hotBgId: "bg_box_hot_$param",
      tinyHeight: 25,
      maxHeight: 150,
      width: 10,
      spacer: 2
    },
    lbl: {
      clsNorm: "b-widget-chart__lbl",
      clsTiny: "b-widget-chart__lbl b-widget-chart__lbl_type_tiny",
      indentTinyBottom: 2,
      indentLeft: 8
    }
  };


  /*
    Функція-обгортка необхідна, щоб уберегти хеш options від деребану між віджетами
   */

  theWidgetInstData = function() {
    return {
      cfg: theWidgetInstConfig,
      barColor: "black",
      hotColor: "black",
      hotBgId: theWidgetInstConfig.bar.hotBgId,
      drawData: null,
      site: null,
      limUsers: 0,
      minUsers: 0,
      maxUsers: 0,
      avgUsers: 0,
      instId: 0
    };
  };


  /**
   * Шаблон для наслідування єкземпляром класу віджету.
   * У порівнянні з попередньою версією, передбачена можливість настройки віджету після старту.
   * Можна як вибрати порогову кількість відвідувачів, так і перепідписатися на інший сайт.
   * Вищезгадані опції відкриваються новою хнопкою в ПН-СХ куті віджету.
   */

  blueprint = {
    partials: {
      chart: strChart()
    },
    template: strTemplate(),
    data: theWidgetInstData,
    _CFG_: theWidgetInstConfig,
    _barColor: "black",
    _history: null,
    _historySum: 0,
    _historySteps: 0,
    _overwlown: null,
    _requestUrl: null,
    _dead: null,
    _min: Number.MAX_VALUE,
    _max: 0,
    _avg: 0,
    _lim: 1,
    oninit: function() {
      var hotBgId, initialData, method, scope;
      method = this._clbResponse;
      scope = this;
      this._clbResponse = function() {
        return method.apply(scope, arguments);
      };
      initialData = this.initialData;
      delete this.initialData;
      this._history = [];
      this._overflown = false;
      this._dead = false;
      this._requestUrl = initialData.site + "/" + this.serverUrl;
      this._lim = initialData.limUsers;
      this._barColor = initialData.barColor;
      hotBgId = this.get("hotBgId");
      hotBgId = hotBgId.replace("$param", initialData.instId);
      this.set("instId", initialData.instId);
      this.set("hotBgId", hotBgId);
      this.set("barColor", initialData.barColor);
      this.set("hotColor", "url('#" + hotBgId + "')");
      this.set("limUsers", initialData.limUsers);
      this.set("site", initialData.site);
      this.set("drawData", []);
      this.on({
        suicide: this.suicide
      });
      return this._askData();
    },
    onteardown: function() {
      return this._dead = true;
    },
    siteName: function(rawName) {
      if (rawName !== ".") {
        return rawName;
      } else {
        return this.get("cfg.thisSite");
      }
    },
    suicide: function() {
      if (this.suicideCallback != null) {
        return this.suicideCallback(this);
      }
    },
    _refreshData: function() {
      var amount, data, limit, pointer;
      data = this.get("drawData");
      if (this._overflown) {
        data.shift();
      }
      pointer = -1;
      limit = this._history.length;
      while (++pointer < limit) {
        amount = this._history[pointer];
        data[pointer] = this._changeInfo(amount, pointer, data[pointer]);
      }
      return this.set("drawData", data);
    },
    _changeInfo: function(amount, index, data) {
      var bar, barH, barSize, cfg, isHot, isTiny, lbl;
      cfg = this._CFG_;
      bar = cfg.bar;
      lbl = cfg.lbl;
      if (data == null) {
        isHot = amount > this._lim;
        barSize = (!isHot ? amount / this._lim : 1);
        barH = barSize * bar.maxHeight;
        isTiny = barH < bar.tinyHeight;
        data = {
          bar: {
            bg: (isHot ? this.get("hotColor") : this._barColor),
            y: 0,
            w: bar.width,
            h: barH
          },
          lbl: {
            text: amount,
            cls: (isTiny ? lbl.clsTiny : lbl.clsNorm),
            y: (isTiny ? barH + lbl.indentTinyBottom : 0.5 * barH)
          }
        };
      }
      data.bar.x = index * (bar.width + bar.spacer);
      data.lbl.x = data.bar.x + lbl.indentLeft;
      return data;
    },
    _askData: function() {
      if (!this._dead) {
        return $.post(this._requestUrl, this._clbResponse);
      }
    },
    _clbResponse: function(data) {
      if (!this._dead) {
        this._nextData(data);
        return this._askData();
      }
    },
    _nextData: function(currentAmount) {
      if (currentAmount > 0) {
        this._overflown = this._history.length >= this._CFG_.historySize;
        if (this._overflown) {
          this._history.shift();
        }
        this._history.push(currentAmount);
        this._historySum += currentAmount;
        this._historySteps++;
        this._avg = Math.round(this._historySum / this._historySteps);
        this._min = Math.min(this._min, currentAmount);
        this._max = Math.max(this._max, currentAmount);
        this._refreshData();
        this.set("minUsers", this._min);
        this.set("maxUsers", this._max);
        return this.set("avgUsers", this._avg);
      }
    }
  };

  pkg.TheWidget = Ractive.extend(blueprint);

}).call(this);
