 -= ЗВІТ ПО ВИКОНАННЮ ЗАВДАННЯ =-
 
1. Структура коду
  1.1. TheWidget.<coffee/js>:
    1.1.1. TheWidgetManager:
      - працює з Local Storage (зберігає і зчитує інформацію про існуючі віджети)
      - моніторить користувацький ввід на сторінці документу
      - вставляє/видаляє екземпляри віджету
      - реагує на зміну серверної інформації, розсилаючи її зареєстрованим віджетам
    1.1.2. TheWidget:
      - відображає інформацію від менеджера у виді діаграми
      - сигналізує про надмірну активність "користувачів" градієнтним почорнінням стовпчика
      - очікує (кнопка "Х") запросу на видалення для передачі його менеджеру
    1.1.3. ActivityWatcher:
      - здійснює безперервне опитування "сервера"
  1.2. helpers.<coffee/js>
    1.2.1. jQWERTY
      - пародія на jQuery, містить єдину функцію, що мімітує роботу $.post(...)
    1.2.2. ServerEmulator
      - симулює затримку відповіді на запит
      - симулює активність на сервері (вхід/вихід користувачів)
      - працює незалежно від наявності/відсутності запитів
  1.3.
    - стилізація панелі віджету
    - стилізація svg-діаграми
 
2. Інструкція англомовному тестеру
  The main problem for the widget manager is a change of placeholders amount. Here are some possible cases:
    - dynamic removal of placeholder does not cancel its registration in the widget manager (mouse events handler will continue its work).
    - dynamic adding a new placeholder not include it in the register of the widget manager.
    - if the widget is in the last placeholder and if on next document load will be less number of placeholders, then this widget will not be able to be revealed on the page.
 
  P.S.: Sorry for my google-translate :(
 
3. Пояснення, відмазки і запитання
  3.1. (!) від Леоніда: не працює збереження в localStorage в IE10
    Як і обіцяв, привожу ссилку на пояснення, на рахунок неспроможності IE розвернутись на всю при використанні протоколу file
    https://stackoverflow.com/questions/19328469/in-ie10-localstorage-in-window-condition-is-true-but-localstorage-is-undefin
 
  3.2. (?) від Леоніда: return в кінці функцій coffeescript зайвий
    Ще Pascal мене навчив, що існує два типи підпрограм:
    - функції (повертають єдиний результат своєї роботи)
    - процедури (не повертають нічого)
    Звичайно, передача аргументів по ссилці дозволяла творити різні "безчинства", впливаючи на значення цих аргументів, ігноруючи тим самим призначення підпрограм. Однак то була лиш опціональна можливість, яку можна в окремих випадках навіть серйозно аргументувати.
    З переходом на мови C-подібного синтаксису мені спочатку бракувало формального розділення ролей між підпрограмами. Хоча завжди виручав оператор `return` - якщо він викликався без операнда, значить підпрограма веде себе, як процедура, інакше - як функція.
    Нарешті переходжу до суті запитання.
    Хоча ненавмисне повернення значення посліднього виразу в функції і може бути ознакою дирявої інкапсуляції, але в переважній більшості ситуацій цим можна нехтувати. Однак є ще один аргумент за явний `return` в кінці...
    Справа в тім, що я помітив зовсім не очевидну (хоч і логічну) поведінку coffescript-компілятора:
      ЯКЩО ПОСЛІДНІМ ОПЕРАТОРОМ ФУНКЦІЇ БУДЕ ЦИКЛ,
      ТО ФУНКЦІЯ ПОВЕРНЕ НЕ ОБЧИСЛЕННЯ ПОСЛІДНЬОГО ВИРАЗУ ПОСЛІДНЬОЇ ІТЕРАЦІЇ,
      А МАСИВ ВСІХ ТАКИХ ЗНАЧЕНЬ ДЛЯ КОЖНОЇ ІТЕРАЦІЇ!!!
    Звичайно, якщо в результуючий масив попадуть не найважливіші данні на світі, то можна на них і плюнути, але лишній масив і лишній код мене трохи дратують. В рідкісних ситуаціях така поведінка може бути корисною, але тільки в РІДКІСНИХ. Мені відомий метод боротьби з такою проблемою - це маленький самотній `return` в кінці функції, який може здатись ЗАЙВИМ...
    Який із перерахованих стилів поведінки вважатиметься оптимальним?
     * плюю на все (і на `return` в тому числі)
     * звикаю ставити `return` там, де не передбачено повернення результату
     * свідомо ставлю `return` там, де його відсутність буде сильно відчутною
 
  3.3. (!) від Леоніда: середні значення стовпчиків ростуть з часом
    Все по плану! Справа в тім, що віджет веде статистику від початку своєї роботи, а не тільки для даних, що відображені на діаграмі. Тут головне, щоб середнє значення не завалювалось за діапазон між мінімумом і максимумом.
 
  3.4. (...) від Леоніда: дані в віджетах повторюються
    І так, і ні... Причина тому - вільне трактування умови задачі. Просто потенціал віджет-менеджера не був реалізований сповна. Тоді я орієнтувався на "користувач може ставити віджети (в даному випадку ЛИШЕ ОДИН)". Я грішним ділом подумав, що віджет повинен працювати з сайтом, на сторінці якого він і працює. А віджет для іншого сайта буде на тому ІНШОМУ сайті. Тому для демонстрації оптимізації я зробив єдиний для всіх віджетів механізм отримання даних. А незалежність віджетів виражалась в тому, що навіть користуючись єдиним джерелом даних, всі вони вели свою історію і свою статистику. Такі віджети будуть ідентичними лише якщо будуть запущені одночасно.
    Однак той же віджет можна зв"язати з іншим джерелом даних і отримати бажаний результат. В новій версії я повністю реалізував задумку з підключеннями до різних сайтів.
 
  3.5. (?) від Юри: помилки при видаленні віджета
    Провіряв перед відправленням і не наткнувся... Підкажи, на якому браузері, або в якій ситуації воно спотикається.
    Мої браузери:
     - Internet Explorer ver:10.0.9200.17183
     - Opera ver:45.0.2552.812 (PGO)
     - Firefox ver:43.0.1
     - Google Chrome ver: 58.0.3029.110 (64-bit)
 
  3.6. (!) від Юри: всі css правила мають бути у зовнішніх файлах
    Я насправді трохи засмітив page.html, але той css-фрагмент, на який ти звернув увагу я навмисне залишив тому, що він був частиною умови. В такому виді я отримав задачу і свідомо вирішив нічого не змінювати. Мені здалось, що так буде легше відділити мою роботу від власне умови. Але звісно, винести стиль в окремий файл - не проблема.
 
 
  3.7. (...) від Юри: class TheWidgetMnager. Зроби його нормальним класом, з якого твориться інстанс...
    Я частково пояснив причину такого підходу, відповідаючи Льоні в п.3.4. Зараз я зробив все як замовлено, але надіюсь що більше одного інстансу не знадобиться. Справа в тім, що менеджер прослуховує мишиний ввід на сторінці і менеджер(И) будуть перекрикувати однин одного своїми реакціями на івенти.
    Справа в тім, що і в єдиному екземплярі віджет-менеджер здатний працювати з різними сайтами. Просто я не зразу збагнув, що мій код настільки  був спрощеним, що це було не очевидно. Надіюсь, що поточна версія буде якіснішою.
 
  3.8. (?) від Юри: подивися уважно на документ проекту і подумай якого класу не вистачає для спрощення коду
    Я не зовсім зрозумів про спрощення якого аспекту йшла мова, тому наплодив додаткових класів стільки, скільки зміг виокремити окремих задач. Такий підхід мабуть є плюсом до читабельності, але перформанс явно постраждав через лишні виклики методів і коллбеків. Якщо я все таки не здогадався, яким методом ти б спростив код, то я б попросив поки що не давати мені правильної відповіді, але хоч злегка натякни в якому напрямку ти помітив проблеми - мені вже самому цікаво в чім там проблема.
