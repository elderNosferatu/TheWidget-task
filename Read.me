 -= ЗВІТ ПО ВИКОНАННЮ ЗАВДАННЯ =-

1. Структура коду
  1.1. TheWidget.<coffee/js>:
    1.1.1. TheWidgetManager:
      - працює з Local Storage (зберігає і зчитує інформацію про існуючі віджети)
      - моніторить користувацький ввід на сторінці документу
      - вставляє/видаляє екземпляри віджету
      - реагує на зміну серверної інформації, розсилаючи її зареєстрованим віджетам
    1.1.2. TheWidget:
      - відображає інформацію від менеджера у виді діаграми
      - сигналізує про надмірну активність "користувачів" градієнтним почорнінням стовпчика
      - очікує (кнопка "Х") запросу на видалення для передачі його менеджеру
    1.1.3. ActivityWatcher:
      - здійснює безперервне опитування "сервера"
  1.2. helpers.<coffee/js>
    1.2.1. jQWERTY
      - пародія на jQuery, містить єдину функцію, що мімітує роботу $.post(...)
    1.2.2. ServerEmulator
      - симулює затримку відповіді на запит
      - симулює активність на сервері (вхід/вихід користувачів)
      - працює незалежно від наявності/відсутності запитів
  1.3.
    - стилізація панелі віджету
    - стилізація svg-діаграми

2. Інструкція англомовному тестеру
  The main problem for the widget manager is a change of placeholders amount. Here are some possible cases:
    - dynamic removal of placeholder does not cancel its registration in the widget manager (mouse events handler will continue its work).
    - dynamic adding a new placeholder not include it in the register of the widget manager.
    - if the widget is in the last placeholder and if on next document load will be less number of placeholders, then this widget will not be able to be revealed on the page.

  P.S.: Sorry for my google-translate :(

3. Запитання
  3.1. Критика `return` в кінці методу
    Ще Pascal мене навчив, що існує два типи підпрограм:
    - функції (повертають єдиний результат своєї роботи)
    - процедури (не повертають нічого)
    Звичайно, передача аргументів по ссилці дозволяла творити різні "безчинства", впливаючи на значення цих аргументів, ігноруючи тим самим призначення підпрограм. Однак то була лиш опціональна можливісь, яку можна в окремих випадках навіть серйозно аргументувати.
    З переходом на мови C-подібного синтаксису мені спочатку бракувало формального розділення ролей між підпрограмами. Хоча завжди виручав оператор `return` - якщо він віикликався без операнда, значить підпрограма веде себе, як процедура, інаше - як функція.
    Нарешті перехожу до суті запитання.
    Хоча ненавмисне повернення значення посліднього виразу в функції і може бути признаком дирявої інкапсуляції, але в переважній більшості ситуацій цим можна нехтувати. Однак є ще один аргумент за явний `return` в кінці...
    Справа в тім, що я помітив зовсім неочевидну (хоч і логічну) поведінку coffescript-компілятора:
      ЯКЩО ПОСЛІДНІМ ОПЕРАТОРОМ ФУНКЦІЇ БУДЕ ЦИКЛ,
      ТО ФУНКЦІЯ ПОВЕРНЕ НЕ ОБЧИСЛЕННЯ ПОСЛІДНЬОГО ВИРАЗУ ПОСЛІДНЬОЇ ІТЕРАЦІЇ,
      А МАСИВ ВСІХ ТАКИХ ЗНАЧЕНЬ ДЛЯ КОЖНОЇ ІТЕРАЦІЇ!!!
    Звичайно, якщо в результуючий масив попадуть не найважливіші данні на світі, то можна на них і плюнути, але лишній масив і лишній код мене трохи дратують. В рідкісних ситуаціях така поведінка може бути корисною, але тільки в РІДКІСНИХ. Мені відомий метод бородьби з такою проблемою - це маленький самотній `return` в кінці функції, який може здатись ЗАЙВИМ...
    Який із перерахованих стилів поведінки вважатиметься оптимальним?
     * плюю на все (і на `return` в тому числі)
     * звикаю ставити `return` там, де не передбачено повернення результату
     * свідомо ставлю `return` там, де його відсутність буде сильно відчутною